//ФОРМУЛЫ
//_________________________________________________________________________________________________________________________

//Вычисление 2
//Написать программу вычисления
//∑_(i = 1) ^ 10▒((-1)) / i!

#include <iostream>  
#include <locale.h>  
#include <cmath>      

using namespace std;

unsigned long long factorial(int n) {
    unsigned long long result = 1;  // Инициализация результата
    // Цикл вычисления факториала (умножение чисел от 2 до n)
    for (int i = 2; i <= n; ++i) {
        result *= i;  // Умножение текущего результата на счётчик
    }
    return result;  // Возврат вычисленного факториала
}

int main() {

    setlocale(LC_ALL, "Russian");

    // Инициализация переменной для хранения суммы ряда
    double sum = 0;

    // Цикл вычисления суммы первых 10 членов ряда
    for (int i = 1; i <= 10; ++i) {
        // Вычисление текущего члена ряда:
        // (-1)^i / i! (чередование знаков и деление на факториал)
        double term = pow(-1, i) / factorial(i);
        // Добавление текущего члена к общей сумме
        sum += term;
    }

    cout << "Сумма ряда: " << sum << endl;

    return 0;
}

//_________________________________________________________________________________________________________________________
//Вычисление 3
//Вычислить бесконечное произведение с заданной точностью е.
//Считать, что требуемая точность достигнута, если очередной сомножитель отличается от единицы меньше, чем на е.
//Этот и все последующие сомножители можно не учитывать.
S = ∏_(i = 1) ^ ∞▒(1 - 1 / (2i + 1) ^ 2)

#include <iostream> 
#include <cmath>      
#include <locale.h>   

using namespace std;
int main() {

    setlocale(LC_ALL, "Russian");

    // Объявление переменной для хранения точности вычислений
    double epsilon;

    cout << "Введите точность: ";

    cin >> epsilon;

    // Инициализация переменной для хранения результата произведения
    // Начальное значение 1.0, так как произведение начинается с 1

    double count = 1.0; // Счётчик итераций (номер текущего множителя)
    int i = 1;

    // Бесконечный цикл для вычисления произведения
    while (true) {
        // Вычисление текущего множителя по формуле:
        // term = 1 - 1/((2i+1)^2)
        double term = 1.0 - 1.0 / pow(2 * i + 1, 2); //Функция pow() в C++ позволяет возвести число в степень другого числа
        // Проверка условия выхода из цикла:
        // Если разница между множителем и 1 стала меньше epsilon,
        // цикл прерывается
        if (fabs(term - 1.0) < epsilon) {
            break;
        }

        // Умножение текущего результата на вычисленный множитель
        count *= term;

        i++;
    }
    // Установка точности вывода (15 знаков после запятой)
    cout.precision(15);

    cout << "Значение произведения: " << count << endl;

    // (i-1, потому что i увеличивается после последней итерации)
    cout << "Число учтённых множителей: " << i - 1 << endl;

    return 0;
}

//_________________________________________________________________________________________________________________________
//Вычисление по формуле
//∏_(i = 2) ^ N▒〖(-1)'(i+1)/(i+2)〗

#include <iostream>   
#include <cmath>      
#include <limits>     // Для работы с numeric_limits
#include <locale.h>   

using namespace std;

int main() {

    setlocale(LC_ALL, "Russian");

    int N;

    // Цикл ввода с проверкой корректности данных
    while (true) {
        cout << "Введите целое число N (N >= 2): ";
        cin >> N;

        // Проверка на ошибку ввода или несоответствие условию
        if (cin.fail() || N < 2) {
            cout << "Ошибка: нужно ввести целое число не меньше 2.\n";
            cin.clear();  // Сброс флага ошибки ввода
            cin.ignore(numeric_limits<streamsize>::max(), '\n');  // Очистка буфера ввода
        }
        else {
            break;  // Выход из цикла при корректном вводе
        }
    }

    // Инициализация переменной для хранения произведения
    // Начальное значение 1.0, так как это нейтральный элемент для умножения
    double znach = 1.0;

    // Цикл вычисления произведения от i=2 до i=N
    for (int i = 2; i <= N; ++i) {
        // Вычисление текущего множителя:
        // (-1)^i * (i+1)/(i+2)
        // static_cast<double> гарантирует вещественное деление
        double term = pow(-1, i) * (static_cast<double>(i + 1) / (i + 2));

        // Умножение произведения на текущий множитель
        znach *= term;
    }

    // Установка точности вывода (15 знаков после запятой)
    cout.precision(15);
    // Вывод конечного результата
    cout << "Результат произведения: " << znach << endl;

    // Завершение программы
    return 0;
}

//_________________________________________________________________________________________________________________________

//Вычисление
//Дано натуральное число n.Вычислить:
//∑_(k = 1) ^ n▒〖k(k + 1)…k ^ 2 〗

#include <iostream>   
#include <locale.h>   

using namespace std;

int main() {

    setlocale(LC_ALL, "Russian");


    int n;
    cout << "Введите n: ";
    cin >> n;

    // Инициализация переменной для хранения суммы
    // Используем long long для предотвращения переполнения при больших n
    long long sum = 0;

    // Цикл вычисления суммы от k=1 до k=n
    for (int k = 1; k <= n; ++k) {
        // Вычисление текущего слагаемого: k³ * (k + 1)
        // и добавление его к общей сумме
        sum += k * k * k * (k + 1); // Эквивалентно k³*(k+1)
    }

    cout << "Сумма: " << sum << endl;

    return 0;
}





